<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥é¾æˆ°é¬¥ - é¾èˆ‡åœ°ä¸‹åŸç‰ˆ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* --- æ ¸å¿ƒè‰²ç¥¨ï¼šDND å¤å…¸é¢¨æ ¼ --- */
            --bg-color: #0f0a08; /* é è¨­æ·±è¤è‰²èƒŒæ™¯ */
            --panel-bg: rgba(20, 15, 12, 0.9); /* ä»‹é¢åº•è‰² */
            
            --c-gold: #c5a059;   /* å¤éŠ…é‡‘ */
            --c-gold-dim: #8a6d3b;
            --c-text: #e0d6c8;   /* ç¾Šçš®ç´™ç™½ */
            
            --c-red: #8a1c1c;    
            --c-red-bright: #ff4d4d;
            --c-blue: #1c4e8a;   
            --c-blue-bright: #4dabf7;
            --c-green: #2b5933;  
            --c-green-bright: #51cf66;
            --c-yellow: #b08d00; 
            --c-orange: #d97706; 
            
            --border-style: 2px solid var(--c-gold);
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            font-family: "Noto Serif SC", serif;
            background-color: var(--bg-color);
            /* é è¨­èƒŒæ™¯ï¼Œæœƒè¢« JS è¦†è“‹ */
            background-image: radial-gradient(circle at center, #1a1512, #050403);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            color: var(--c-text); 
            margin: 0; overflow: hidden; position: relative;
            width: 1080px; height: 720px;
            transition: background-image 0.5s ease-in-out; /* èƒŒæ™¯åˆ‡æ›å‹•ç•« */
        }

        h1, h2, .defeat-title, .sel-title, .boss-title-row, .cell-big-text, .php-val {
            font-family: "Cinzel", "Noto Serif SC", serif; 
            text-transform: uppercase;
        }

        /* === è¼‰å…¥èˆ‡çµæŸç•«é¢ === */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; color: var(--c-gold);
            font-family: "Cinzel", serif;
            border: 4px double var(--c-gold);
        }

        #defeat-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 3000;
            display: none; flex-direction: column; justify-content: center; align-items: center; gap: 30px;
            animation: fadeIn 0.5s;
            backdrop-filter: blur(5px);
        }
        .defeat-title { 
            font-size: 4rem; color: var(--c-red-bright); 
            text-shadow: 0 0 20px #500; margin-bottom: 20px; 
            letter-spacing: 5px; border-bottom: 2px solid var(--c-red);
        }
        .defeat-btn-group { display: flex; gap: 40px; }
        .d-btn {
            padding: 15px 40px; font-size: 1.5rem; 
            border: 2px solid var(--c-text); 
            background: rgba(0,0,0,0.5); color: var(--c-text);
            cursor: pointer; transition: 0.2s; border-radius: 4px; 
            font-family: "Cinzel", serif;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .d-btn:hover { transform: scale(1.05); background: var(--c-text); color: #000; }
        .d-btn.skip { border-color: var(--c-gold); color: var(--c-gold); }
        .d-btn.skip:hover { background: var(--c-gold); color: #000; box-shadow: 0 0 20px var(--c-gold); }

        /* === éŠæˆ²ä¸»å ´æ™¯ === */
        #game-stage {
            width: 100%; height: 100%; position: relative; display: none;
            /* å¾®å¾®çš„æš—è§’æ•ˆæœ */
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
        }

        /* === é¸æ“‡ä»‹é¢ === */
        #selection-screen {
            width: 100%; height: 100%;
            position: absolute; top: 0; left: 0; z-index: 999;
            background: rgba(10, 8, 6, 0.98);
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .sel-header { display: flex; flex-direction: column; align-items: center; margin-bottom: 20px; }
        .sel-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;
            max-width: 900px; margin: 20px;
        }
        .sel-card {
            background: linear-gradient(to bottom, #2a2522, #1a1512); 
            border: 1px solid #554433; 
            padding: 15px; border-radius: 4px; 
            cursor: pointer; transition: 0.2s;
            display: flex; flex-direction: column; gap: 5px;
            width: 200px; height: 140px; position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .sel-card.selected { 
            border-color: var(--c-gold); 
            background: #2b2210; 
            box-shadow: 0 0 15px var(--c-gold), inset 0 0 10px var(--c-gold-dim); 
        }
        .sel-card:hover { transform: translateY(-5px); border-color: #888; }
        .sel-title { font-weight: bold; color: var(--c-gold); font-size: 1.1rem; border-bottom: 1px solid #443322; padding-bottom: 2px;}
        .sel-owner { font-size: 0.8rem; color: #aaa; margin-bottom: 5px; font-style: italic; }
        .sel-desc { font-size: 0.8rem; color: #ccc; line-height: 1.4; font-family: "Noto Serif SC", serif; }
        
        .enemy-selector {
            padding: 10px; font-size: 1.2rem; background: #000; color: var(--c-gold); 
            border: 1px solid var(--c-gold); margin-top: 10px; font-family: inherit;
        }

        .btn-start {
            padding: 10px 50px; font-size: 1.5rem; font-weight: bold;
            background: var(--c-gold); color: #1a0f00; border: 2px solid #fff; 
            cursor: pointer; margin-top: 20px; border-radius: 2px;
            font-family: "Cinzel", "Noto Serif SC", serif;
            box-shadow: 0 0 20px rgba(197, 160, 89, 0.4);
        }
        .btn-start:hover { filter: brightness(1.2); letter-spacing: 2px; transition: 0.3s; }

        /* === BOSS å€åŸŸ === */
        .area-top { 
            position: absolute; top: 10px; left: 150px; right: 280px; height: 140px; 
            display: flex; flex-direction: column; align-items: center; z-index: 10; 
        }
        .boss-hp-box { 
            width: 100%; 
            border: 2px solid var(--c-gold); 
            padding: 8px; 
            background: rgba(0,0,0,0.8); 
            position: relative; 
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .boss-title-row { display: flex; justify-content: space-between; font-size: 1.3rem; margin-bottom: 5px; color: var(--c-gold); text-shadow: 0 2px 2px #000; }
        .hp-track { 
            width: 100%; height: 20px; background: #221111; 
            border: 1px solid #442222; box-shadow: inset 0 0 5px #000;
        }
        .hp-fill { 
            height: 100%; 
            background: linear-gradient(to right, #8a1c1c, #e03131); 
            width: 100%; transition: width 0.15s ease-out; 
            box-shadow: 0 0 10px rgba(224, 49, 49, 0.5);
        }
        
        .condition-box { 
            margin-top: 8px; border: 1px solid var(--c-blue-bright); 
            background: rgba(0, 10, 20, 0.8); 
            padding: 6px 20px; font-size: 1.1rem; color: #add8e6; 
            box-shadow: 0 0 10px rgba(77, 171, 247, 0.2);
            transition: all 0.3s; text-align: center; width: 100%;
            font-family: "Cinzel", serif;
            border-left: 5px solid var(--c-blue-bright); 
        }

        .special-status-box, .sum-display-box {
            margin-top: 5px; font-size: 1.2rem; color: var(--c-gold);
            font-weight: bold; text-shadow: 0 0 5px #000; display: none; gap: 15px;
        }
        .check-item.done { color: var(--c-green-bright); text-shadow: 0 0 10px var(--c-green-bright); }
        .sum-display-box { animation: pulseText 2s infinite alternate; }

        .ingame-skip-btn {
            position: absolute; right: -37px; top: 0;
            width: 30px; height: 30px; background: #222; border: 1px solid #444; color: #666;
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            font-size: 1.2rem; border-radius: 4px; transition: 0.2s;
        }
        .ingame-skip-btn:hover { color: var(--c-gold); border-color: var(--c-gold); }

        /* === Phase Orb === */
        .area-left { 
            position: absolute; top: 10px; left: 20px; bottom: 400px; width: 80px; 
            border: 2px solid #553333; 
            background: rgba(20, 10, 10, 0.6); 
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 20px; gap: 15px; z-index: 10; border-radius: 4px; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .lives-label { font-weight: bold; color: #8a1c1c; margin-bottom: 5px; font-size: 0.8rem; text-align: center; font-family: "Cinzel", serif; }
        .life-orb { 
            width: 40px; height: 40px; 
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #820000); 
            border-radius: 50%; border: 2px solid #442222; 
            box-shadow: 0 0 10px #f00, inset 2px 2px 5px rgba(255,255,255,0.4); 
            transition: 0.3s; 
        }
        .life-orb.lost { 
            background: #111; border-color: #333; box-shadow: inset 0 0 5px #000; 
            transform: scale(0.8); opacity: 0.5; 
        }

        /* === æ•µæ–¹æ„åœ– === */
        .area-right-top { 
            position: absolute; top: 10px; right: 20px; width: 220px; height: 130px; 
            border: 2px solid var(--c-red);
            background: rgba(30, 10, 10, 0.9); padding: 10px; 
            text-align: center; z-index: 10; border-radius: 4px; 
            display: flex; flex-direction: column; justify-content: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            clip-path: polygon(0 0, 100% 0, 100% 90%, 90% 100%, 0 100%);
        }
        .area-right-top.broken {
            border-color: var(--c-green-bright);
            background: rgba(0, 40, 0, 0.85);
        }
        .intent-label { font-size: 1rem; color: #ffa8a8; font-weight: bold; margin-bottom: 5px; font-family: "Cinzel", serif; }
        .dmg-val { 
            font-size: 3.5rem; color: #ff4d4d; font-weight: bold; 
            line-height: 1; text-shadow: 0 0 10px #500; margin-bottom: 5px;
            font-family: "Cinzel", serif;
        }
        .def-info { font-size: 0.9rem; color: #aaa; }
        .def-val { color: var(--c-green-bright); font-weight: bold; margin-left: 5px; font-size: 1.1rem; }

        /* === [ä¿®æ”¹] æŠ€èƒ½æ¬„ï¼š2x2 ç¶²æ ¼ä½ˆå±€ === */
        .area-right-mid { 
            position: absolute; top: 150px; right: 20px; bottom: 260px; 
            width: 220px; 
            border: 2px solid #555; 
            background: rgba(20, 20, 20, 0.8); 
            display: flex; flex-direction: column; 
            padding: 8px; gap: 8px;
            z-index: 10; border-radius: 4px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        .skill-title {
            color: var(--c-orange); 
            font-weight: bold; 
            text-align: left;
            padding-bottom: 4px;
            border-bottom: 1px solid #444;
            font-family: "Noto Serif SC", serif;
        }

        .skill-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 6px;
            flex-grow: 1; /* ä½”æ»¿å‰©é¤˜é«˜åº¦ */
        }
        
        .skill-btn {
    background: linear-gradient(to bottom, #2b2b2b, #1a1a1a); /* æ·±è‰²èƒŒæ™¯ */
    border: 1px solid #555; 
    color: #ddd; 
    cursor: pointer; 
    display: flex; 
    flex-direction: column; 
    justify-content: flex-end; /* å…§å®¹é ä¸‹å°é½Š */
    align-items: center;
    text-align: center;
    width: 100%; height: 100%; 
    transition: 0.2s; border-radius: 4px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.5);
    padding: 5px;
    position: relative;
    overflow: hidden; /* é˜²æ­¢åœ–ç‰‡è¶…å‡º */
}
		.skill-btn .s-img {
    position: absolute;
    top: 5px; /* åœ–ç‰‡è·é›¢é ‚éƒ¨ */
    height: 65%; /* åœ–ç‰‡é«˜åº¦ä½”æ¯” */
    width: auto;
    object-fit: contain;
    filter: drop-shadow(0 0 5px rgba(0,0,0,0.8));
    transition: 0.2s;
    z-index: 1;
}

        .skill-btn .s-name { 
    font-family: "Noto Serif SC", serif;
    font-weight: bold; 
    font-size: 1.1rem; 
    color: #fff;
    text-shadow: 0 0 3px #000, 0 0 5px #000;
    z-index: 2;
    margin-bottom: 2px;
}
        .skill-btn .s-cost { font-size: 0.75rem; color: #aaa; }
        .skill-btn .s-count { 
    font-family: "Cinzel", serif;
    font-size: 0.9rem; 
    color: #ffd43b; 
    font-weight: bold;
    text-shadow: 0 1px 2px #000;
    z-index: 2;
}
		.skill-btn:hover:not(:disabled) .s-img {
    transform: scale(1.1);
}

        .skill-btn:hover:not(:disabled) { 
    background: #333; 
    border-color: #888; 
}
        .skill-btn.active { 
    border-color: var(--c-gold); 
    background: #3d3015; 
    box-shadow: 0 0 10px var(--c-gold-dim); 
}
        .skill-btn.targetable-skill { border-color: var(--c-green); background: #0f2b15; cursor: crosshair; }
        .skill-btn:disabled { 
    opacity: 0.5; 
    cursor: not-allowed; 
    filter: grayscale(0.8); 
}

        /* === ç©å®¶ HP === */
        .area-right-bot { 
            position: absolute; bottom: 20px; right: 20px; width: 220px; height: 230px; 
            border: 3px double var(--c-green-bright); 
            background: radial-gradient(circle, rgba(0,40,0,0.9), #001100); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 10; border-radius: 50%; 
            box-shadow: 0 0 30px rgba(81, 207, 102, 0.2); 
        }
        .php-val { font-size: 4.5rem; font-weight: bold; line-height: 1; color: var(--c-green-bright); text-shadow: 0 0 15px var(--c-green); }
        .php-lbl { font-size: 1rem; color: #8ce99a; margin-top: 5px; font-family: "Cinzel", serif; }

        /* === å„€è¡¨æ¿ === */
        .dashboard-container { 
            position: absolute; bottom: 160px; left: 120px; right: 260px; height: 200px; 
            z-index: 20; 
            transform: perspective(800px) rotateX(20deg); 
            transform-origin: bottom center; 
            border: 4px solid #3e3025; 
            background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMjYyMTE5IiAvPgo8L3N2Zz4=');
            background-color: #262119;
            display: grid; grid-template-columns: 1fr 240px; 
            box-shadow: 0 30px 60px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.8);
        }
        .dash-left { border-right: 2px solid #3e3025; padding: 10px 20px; display: flex; flex-direction: column; }
        .track-box { 
            flex-grow: 1; background: rgba(0,0,0,0.4); border: 1px inset #554433; 
            display: flex; align-items: center; padding: 0 10px; gap: 5px; overflow-x: hidden; 
        }
        
        .dash-right { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .dash-cell { border-bottom: 1px solid #3e3025; border-right: 1px solid #3e3025; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; }
        .dash-cell:nth-child(2n) { border-right: none; } .dash-cell:nth-child(n+3) { border-bottom: none; }
        .cell-tag { position: absolute; top: 5px; left: 5px; font-size: 0.7rem; color: #887766; font-family: "Cinzel", serif; }
        .cell-big-text { font-size: 2rem; font-weight: bold; color: #e0d6c8; }
        
        .btn-full { width: 100%; height: 100%; border: none; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: 0.2s; font-family: "Noto Serif SC", serif; }
        .btn-restart { background: #3d332a; color: #aaa; } .btn-restart:hover { color: white; background: #554433; }
        .btn-end { background: #1a1510; color: #d4af37; border-top: 2px solid #d4af37; } 
        .btn-end:hover { background: #2b2210; box-shadow: inset 0 0 20px #d4af37; text-shadow: 0 0 10px #d4af37; }

        /* === æ‰‹ç‰Œå€ === */
        .area-hand { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 170px; 
            background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0)); 
            display: flex; justify-content: center; align-items: center; gap: 10px; z-index: 50; 
            padding-bottom: 10px;
        }
        
        .card { 
            width: 90px; height: 120px; 
            background: #222; border-radius: 8px; 
            border: 2px solid #aaa; 
            display: flex; justify-content: center; align-items: center; 
            font-size: 2.5rem; font-weight: bold; color: white; 
            cursor: pointer; transition: transform 0.15s, filter 0.2s; 
            position: relative; 
            box-shadow: 0 5px 10px rgba(0,0,0,0.7);
            font-family: "Cinzel", serif;
        }
        .card:hover { transform: translateY(-30px) scale(1.1); border-color: white; z-index: 100; box-shadow: 0 0 20px rgba(255,255,255,0.3); }
        
        .card.red { background: linear-gradient(135deg, #5c0000, #2b0000); border-color: #ff8787; text-shadow: 2px 2px 0 #000;} 
        .card.blue { background: linear-gradient(135deg, #002a7a, #001133); border-color: #74c0fc; text-shadow: 2px 2px 0 #000;} 
        .card.green { background: linear-gradient(135deg, #1b4d24, #051f0a); border-color: #69db7c; text-shadow: 2px 2px 0 #000;} 
        .card.yellow { background: linear-gradient(135deg, #946c00, #3d2c00); color: #fff; border-color: #ffd43b; text-shadow: 2px 2px 0 #000;}
        
        .card.token::after { 
            content: "T"; position: absolute; top: 5px; right: 5px; 
            font-size: 0.7rem; color: #111; 
            border: 1px solid #d4af37; border-radius: 50%; 
            width: 20px; height: 20px; 
            display: flex; justify-content: center; align-items: center; 
            background: #d4af37; box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            font-family: sans-serif;
        }

        .card.disabled { 
            filter: brightness(0.8) grayscale(0.6); 
            opacity: 0.7; cursor: not-allowed; border-color: #333; transform: scale(0.95); box-shadow: none;
        }
        .card.disabled:hover { transform: scale(0.95); border-color: #333; z-index: 0; }
        .card.targetable { animation: glow 1s infinite alternate; border-color: white; cursor: crosshair; filter: brightness(1.2); }

        .mini-card { 
            width: 30px; height: 45px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.3); 
            display: flex; justify-content: center; align-items: center; font-size: 0.9rem; font-weight: bold; 
            flex-shrink: 0; color: white; text-shadow: 1px 1px 0 #000; 
            font-family: "Cinzel", serif;
        }
        .mini-card.red { background: #8a1c1c; } .mini-card.blue { background: #1c4e8a; } 
        .mini-card.green { background: #2b5933; } .mini-card.yellow { background: #b08d00; }
        
        .boss-img-container { 
            position: absolute; top: 250px; left: 160px; right: 280px; bottom: 200px; 
            pointer-events: none; z-index: 5; display: flex; justify-content: center; align-items: center; 
        }
        .boss-img { max-height: 230%; max-width: 230%; filter: drop-shadow(0 0 20px rgba(0,0,0,0.8)); animation: float 3s infinite ease-in-out; }

        #log-overlay { 
            position: fixed; top: 150px; left: 50%; transform: translateX(-50%); 
            text-align: center; pointer-events: none; z-index: 9999; 
            text-shadow: 0 0 10px black; font-size: 2.5rem; font-weight: bold; 
            color: var(--c-gold); opacity: 0; transition: opacity 0.2s; 
            font-family: "Cinzel", serif; letter-spacing: 2px;
        }
        
        /* === é¡è‰²é¸æ“‡å™¨ === */
        #color-picker { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); z-index: 2000; 
            display: none; justify-content: center; align-items: center; flex-direction: column; gap: 20px; 
        }
        .cp-options { display: flex; gap: 30px; }
        .cp-btn { 
            width: 80px; height: 80px; border: 3px solid #555; cursor: pointer; border-radius: 50%;
            transition: 0.2s; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: relative;
        }
        .cp-btn:hover { transform: scale(1.1); border-color: #fff; }
        .cp-btn::after { content: ""; position: absolute; inset: 5px; border: 1px dashed rgba(255,255,255,0.5); border-radius: 50%; }

        @keyframes glow { from { box-shadow: 0 0 5px white; } to { box-shadow: 0 0 20px gold; transform: translateY(-20px); } }
        @keyframes pulse { 0% { border-color: var(--c-orange); } 50% { border-color: white; box-shadow: 0 0 15px var(--c-orange); } 100% { border-color: var(--c-orange); } }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } 100% { transform: translateX(0); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulseText { from { opacity: 0.7; } to { opacity: 1; text-shadow: 0 0 15px var(--c-gold); } }
        
        .shake { animation: shake 0.3s; }
        .phase-flash { animation: phaseFlash 1s; }
        @keyframes phaseFlash {
            0% { filter: brightness(1); }
            50% { filter: brightness(2) sepia(1) hue-rotate(-50deg); }
            100% { filter: brightness(1); }
        }

        #bgm-toggle-btn {
            position: absolute; bottom: 10px; right: 5px; width: 50px; height: 50px;
            background: radial-gradient(circle, #333, #000);
            border: 2px solid #665544; color: #d4af37;
            font-size: 24px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 1000; border-radius: 50%; transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #bgm-toggle-btn:hover { border-color: #fff; transform: scale(1.1); box-shadow: 0 0 15px #d4af37; }
		
		/* === æ–°å¢ï¼šæœªä¾†è¦–ç•Œå€åŸŸ (å·¦å´ç´…åœˆè™•) === */
.future-sight-container {
    position: absolute;
    bottom: 160px; /* èˆ‡å„€è¡¨æ¿åº•éƒ¨å°é½Š */
    left: 20px;    /* å„€è¡¨æ¿åœ¨ 120pxï¼Œé€™è£¡è¨­åœ¨æ›´å·¦é‚Š */
    width: 80px;
    display: none; /* é è¨­éš±è— */
    flex-direction: column;
    align-items: center;
    gap: 10px;
    z-index: 15;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #554433;
    padding: 10px 5px;
    border-radius: 4px;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    animation: fadeIn 0.5s;
}

.fs-label {
    font-size: 0.8rem;
    color: #aaa;
    font-family: "Cinzel", serif;
    text-align: center;
    border-bottom: 1px solid #444;
    padding-bottom: 5px;
    width: 100%;
}

.fs-card-slot {
    /* æ¯”ä¸€èˆ¬ mini-card ç¨å¤§ä¸€é»ä»¥ä¾¿è¾¨è­˜ */
    width: 40px; 
    height: 56px;
    font-size: 1.2rem;
    box-shadow: 0 0 5px #000;
}
    </style>
</head>
<body>
    <div id="bgm-toggle-btn" class="sys-btn" onclick="toggleLocalMusic()">ğŸ”Š</div>
    <div id="loading-screen">
        æ­£åœ¨è®€å–æˆ°é¬¥è³‡æ–™...
    </div>

    <div id="selection-screen">
        <div class="sel-header">
            <h1 style="color:var(--c-orange); margin-bottom: 5px;">æˆ˜å‰å‡†å¤‡</h1>
            <div style="color:#aaa; margin-bottom: 10px;">é€‰æ‹©æœ€å¤š 4 ä¸ªæ¯çˆ±æ”¯æ´</div>
            
            <div style="display:flex; flex-direction:column; align-items:center;">
                <label style="color:#888; font-size:0.9rem;">æ¸¬è©¦æ•µäººé¸æ“‡ (Debug)</label>
                <select id="debug-enemy-select" class="enemy-selector" onchange="loadBattleData()">
                    </select>
            </div>
        </div>

        <div class="sel-grid" id="skill-grid"></div>
        <button id="btn-start-game" class="btn-start" onclick="finalizeSelection()">å¼€å§‹æˆ˜æ–—</button>
    </div>

    <div id="defeat-modal">
        <div class="defeat-title" id="defeat-title">å¤±è´¥</div>
        <div class="defeat-btn-group">
            <button class="d-btn" onclick="retryGame()">â†» é‡æ–°æŒ‘æˆ˜</button>
            <button class="d-btn skip" onclick="skipBattle()">â© è·³è¿‡æˆ˜æ–—</button>
        </div>
    </div>

    <div id="color-picker">
        <h2 style="color:white">é€‰æ‹©è½¬æ¢åçš„ç›®æ ‡é¢œè‰²</h2>
        <div class="cp-options">
            <div class="cp-btn" style="background:#e03131" onclick="resolveColorPick('red')"></div>
            <div class="cp-btn" style="background:#1864ab" onclick="resolveColorPick('blue')"></div>
            <div class="cp-btn" style="background:#2b8a3e" onclick="resolveColorPick('green')"></div>
            <div class="cp-btn" style="background:#f08c00" onclick="resolveColorPick('yellow')"></div>
        </div>
        <button onclick="cancelColorPick()" style="margin-top:20px; padding:10px 20px; font-size: 1.2rem; cursor: pointer;">å–æ¶ˆ</button>
    </div>

    <div id="log-overlay"></div>

    <div id="game-stage">
        <div class="area-top">
            <div class="boss-hp-box">
                <div class="boss-title-row">
                    <span id="enemy-name">BOSS</span>
                    <span id="hp-text">200/200</span>
                </div>
                <div class="hp-track"><div id="hp-bar" class="hp-fill"></div></div>
                <div class="ingame-skip-btn" onclick="skipBattle()" title="ä½œå¼Šï¼šç›´æ¥å‹åˆ©">â©</div>
            </div>
            <div class="condition-box" id="condition-text">èƒœåˆ©æ¡ä»¶: å‡»è´¥æ•Œäºº</div>
            
            <div class="sum-display-box" id="sum-display">å½“å‰æ€»å’Œ: 0 / ç›®æ ‡: 15</div>
            
            <div class="special-status-box" id="special-status">
                </div>
        </div>

        <div class="area-left">
            <div class="lives-label">BOSS<br>PHASES</div>
            <div class="life-orb" id="orb-1"></div>
            <div class="life-orb" id="orb-2"></div>
            <div class="life-orb" id="orb-3"></div>
            <div class="life-orb" id="orb-4" style="display:none"></div> </div>

        <div class="area-right-top" id="intent-box">
            <div class="intent-label" id="intent-label">ä¼¤å®³é¢„å…†</div>
            <div class="dmg-val" id="enemy-intent-val">0</div>
            <div class="def-info">è¿å‡»å‡ä¼¤: <span class="def-val" id="def-rate-text">3</span></div>
        </div>

        <div class="area-right-mid" id="equipped-skills-area">
            </div>

        <div class="area-right-bot">
            <div class="php-val" id="player-hp-text">100</div>
            <div class="php-lbl">PLAYER HP</div>
        </div>
        <div id="future-sight-area" class="future-sight-container">
    <div class="fs-label">NEXT<br>DRAWS</div>
    <div id="fs-cards-list" style="display:flex; flex-direction:column; gap:8px;">
        </div>
</div>
        <div class="dashboard-container">
            <div class="dash-left">
                <div style="font-size:0.9rem; color:#aaa; margin-bottom:5px;">HISTORY</div>
                <div class="track-box" id="played-cards-track"><span>ç­‰å¾…å‡ºç‰Œ...</span></div>
            </div>
            <div class="dash-right">
                <div class="dash-cell">
                    <span class="cell-tag">COMBO</span>
                    <span class="cell-big-text" style="color:var(--c-red)" id="combo-count">0</span>
                </div>
                <div class="dash-cell">
                    <span class="cell-tag">DECK</span>
                    <span class="cell-big-text" id="deck-count">40</span>
                </div>
                <div class="dash-cell">
                    <button class="btn-full btn-restart" onclick="retryGame()">é‡æ–°<br>å‡†å¤‡</button>
                </div>
                <div class="dash-cell">
                    <button class="btn-full btn-end" onclick="endTurn()">ç»“æŸ<br>å›åˆ</button>
                </div>
            </div>
        </div>

        <div class="area-hand" id="hand-area"></div>
        
        <div class="boss-img-container">
            <img id="boss-img" class="boss-img" src="">
        </div>
    </div>

<script>
	const IS_DEBUG_MODE = false ;

    // === 1. æŠ€èƒ½æ•¸æ“šåº« (8å€‹) ===
    const SKILLS_DB = [
        { id: 1, owner: "çˆ±å¨œ", name: "æ— ä¸­ç”Ÿæœ‰", cost: 1, max: 3, desc: "æŠ½ 2 å¼ ç‰Œ (æ‰‹ç‰Œä¸º 0 åˆ™ 4 å¼ )" },
        { id: 2, owner: "ç±³æ‹‰éœ²æ©", name: "é¾™è¯­è½¬åŒ–", cost: 1, max: 2, desc: "é€‰å–å…¶å®ƒæ¯çˆ±æ”¯æ´å‘åŠ¨æ•ˆæœ" },
        { id: 3, owner: "ç³", name: "é²œè¡€å¥‘çº¦", cost: 1, max: 2, desc: "é€‰ä¸€å¼ ç‰Œä¸¢å¼ƒï¼Œæ¢å¤ 20 ç”Ÿå‘½" },
        { id: 4, owner: "é»›èŠ¬å¦®", name: "çµé­‚è£å‰ª", cost: 1, max: 2, desc: "å°†ä¸€å¼ ç‰Œåˆ‡åˆ†ä¸ºä¸¤å¼ " },
        { id: 5, owner: "èŠ™è•¾å˜‰", name: "æœªæ¥è§†ç•Œ", cost: 1, max: 1, desc: "3å›åˆå†…ï¼Œæ˜¾ç¤ºç‰Œåº“é¡¶çš„ 3 å¼ ç‰Œ" },
        { id: 6, owner: "ç©—", name: "åƒå˜ä¸‡åŒ–", cost: 1, max: 2, desc: "è½¬æ¢æ‰‹ç‰ŒæŸé¢œè‰²ä¸ºæŒ‡å®šé¢œè‰²" },
        { id: 7, owner: "ç’æ³•", name: "é¼“èˆä¹‹å¿ƒ", cost: 1, max: 1, desc: "3å›åˆå†…ï¼Œå¼€å§‹æ—¶å¤šæŠ½ 2 å¼ ç‰Œ" },
        { id: 8, owner: "è‰è¿ªå¨…", name: "ä¸åŠ¨ä¿¡å¿µ", cost: 1, max: 1, desc: "3å›åˆå†…ï¼Œç»“æŸæ—¶ä¸å¼ƒç‰Œ" }
    ];

	const SKILL_ICONS = {
    "çˆ±å¨œ": "https://files.catbox.moe/k2qqsy.png",    
    "ç³": "https://files.catbox.moe/civeuq.png",     
    "ç±³æ‹‰éœ²æ©": "https://files.catbox.moe/zavdit.png", 
    "é»›èŠ¬å¦®": "https://files.catbox.moe/zuut1k.png",
    "èŠ™è•¾å˜‰": "https://files.catbox.moe/veol33.png",
    "ç©—": "https://files.catbox.moe/vz9bd5.png",
    "è‰è¿ªå¨…": "https://files.catbox.moe/qw2n11.png",
    "ç’æ³•": "https://files.catbox.moe/9sgl35.png"
};
    // === 1.5 æ•µäººæ•¸æ“šåº« (æ–°å¢ bg å±¬æ€§) ===
    const ENEMIES_DB = {
        "enemy_1": { 
            name: "é«˜å¡”çš„é­”å¥³çˆ±å¨œ", 
            img: "https://files.catbox.moe/iurzeo.png",
			bgm: "https://files.catbox.moe/vlllik.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/tfqkcl.png')",
            phases: [
                { hp: 10, atk: 5, mode: "count", desc: "åŸºç¡€ï¼šå‡ºä¸€å¼ ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 10, atk: 5, mode: "count", desc: "åŸºç¡€ï¼šå‡ºä¸€å¼ ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 10, atk: 5, mode: "count", desc: "åŸºç¡€ï¼šå‡ºä¸€å¼ ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 10, atk: 5, mode: "count", desc: "åŸºç¡€ï¼šå‡ºä¸€å¼ ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" }
            ]
        },
        "enemy_2": { 
            name: "é­”å¯¼äººå¶é»›èŠ¬å¦®", 
            img: "https://files.catbox.moe/qmoavv.png",
			bgm: "https://files.catbox.moe/ep9wz3.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/qa47ic.png')",
            phases: [
                { hp: 10, atk: 10, mode: "color_chain", params: {color:'red'}, desc: "çº¢è‰²è¿å‡»ï¼šè¿ç»­å‡ºçº¢ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 10, atk: 12, mode: "color_chain", params: {color:'blue'}, desc: "è“è‰²è¿å‡»ï¼šè¿ç»­å‡ºè“ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 10, atk: 15, mode: "color_chain", params: {color:'green'}, desc: "ç»¿è‰²è¿å‡»ï¼šè¿ç»­å‡ºç»¿ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 10, atk: 18, mode: "color_chain", params: {color:'yellow'}, desc: "é»„è‰²è¿å‡»ï¼šè¿ç»­å‡ºé»„ç‰Œé€ æˆ 1 ç‚¹ä¼¤å®³" }
            ]
        },
        "enemy_3": { 
            name: "å¤©å®«ç‹ä»™ç©—", 
			img: "https://files.catbox.moe/dsyvgw.png",
			bgm: "https://files.catbox.moe/6dk58a.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/0pvzyg.png')",
            phases: [
                { hp: 12, atk: 15, mode: "color_switch", desc: "å˜å¹»ï¼šåˆ‡æ¢é¢œè‰²æ—¶é€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 12, atk: 18, mode: "color_switch", desc: "å˜å¹»ï¼šåˆ‡æ¢é¢œè‰²æ—¶é€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 12, atk: 20, mode: "color_switch", desc: "å˜å¹»ï¼šåˆ‡æ¢é¢œè‰²æ—¶é€ æˆ 1 ç‚¹ä¼¤å®³" },
                { hp: 12, atk: 22, mode: "color_switch", desc: "å˜å¹»ï¼šåˆ‡æ¢é¢œè‰²æ—¶é€ æˆ 1 ç‚¹ä¼¤å®³" }
            ]
        },
        "enemy_4": { 
            name: "è¡€æœˆçœŸç¥–ç³", 
			img: "https://files.catbox.moe/8neyi0.png",
			bgm: "https://files.catbox.moe/r2nk9x.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/70kehc.png')",
            phases: [
                { hp: 30, atk: 20, mode: "diff", desc: "è½å·®ï¼šé€ æˆå‰åç‰Œå·®å€¼çš„ä¼¤å®³" },
                { hp: 35, atk: 22, mode: "diff", desc: "è½å·®ï¼šé€ æˆå‰åç‰Œå·®å€¼çš„ä¼¤å®³" },
                { hp: 40, atk: 25, mode: "diff", desc: "è½å·®ï¼šé€ æˆå‰åç‰Œå·®å€¼çš„ä¼¤å®³" },
                { hp: 45, atk: 28, mode: "diff", desc: "è½å·®ï¼šé€ æˆå‰åç‰Œå·®å€¼çš„ä¼¤å®³" }
            ]
        },
        "enemy_5": { 
            name: "ç”Ÿå‘½æ ‘çš„å®ˆæŠ¤è€…èŠ™è•¾å˜‰", 
			img: "https://files.catbox.moe/bw1nro.png",
			bgm: "https://files.catbox.moe/ho39fr.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/rvixn6.png')",
            phases: [
                { hp: 8, atk: 15, mode: "combo_mod", params: {mod:2}, desc: "äºŒè¿æ‹ï¼šæ¯ 2 è¿å‡»é€ æˆ 1 ä¼¤å®³" },
                { hp: 6, atk: 20, mode: "combo_mod", params: {mod:3}, desc: "ä¸‰è¿æ‹ï¼šæ¯ 3 è¿å‡»é€ æˆ 1 ä¼¤å®³" },
                { hp: 5, atk: 25, mode: "combo_mod", params: {mod:4}, desc: "å››è¿æ‹ï¼šæ¯ 4 è¿å‡»é€ æˆ 1 ä¼¤å®³" },
                { hp: 4, atk: 30, mode: "combo_mod", params: {mod:5}, desc: "äº”è¿æ‹ï¼šæ¯ 5 è¿å‡»é€ æˆ 1 ä¼¤å®³" }
            ]
        },
        "enemy_6": { 
            name: "æ·±æ¸Šä¹¦åº“çš„å¤é¾™ç±³æ‹‰éœ²æ©", 
			img: "https://files.catbox.moe/oyp53t.png",
			bgm: "https://files.catbox.moe/yi2xi9.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/ams5rj.png')",
            phases: [
                { hp: 4, atk: 20, mode: "sum_target", params: {target:10}, desc: "æ€»å’Œ 10ï¼šå‡ºç‰Œæ€»å’Œåˆšå¥½ 10 é€ æˆ 1 ä¼¤å®³" },
                { hp: 4, atk: 22, mode: "sum_target", params: {target:15}, desc: "æ€»å’Œ 15ï¼šå‡ºç‰Œæ€»å’Œåˆšå¥½ 15 é€ æˆ 1 ä¼¤å®³" },
                { hp: 4, atk: 25, mode: "sum_target", params: {target:20}, desc: "æ€»å’Œ 20ï¼šå‡ºç‰Œæ€»å’Œåˆšå¥½ 20 é€ æˆ 1 ä¼¤å®³" },
                { hp: 4, atk: 28, mode: "sum_target", params: {target:25}, desc: "æ€»å’Œ 25ï¼šå‡ºç‰Œæ€»å’Œåˆšå¥½ 25 é€ æˆ 1 ä¼¤å®³" }
            ]
        },
        "enemy_7": { 
            name: "æ°¸ç»­å¸å›½çš„çš‡å¥³è‰è¿ªå¨…", 
			img: "https://files.catbox.moe/nh3jl8.png",
			bgm: "https://files.catbox.moe/025ta8.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/3fbl68.png')",
            phases: [
                { hp: 150, atk: 30, mode: "value", desc: "é‡å‡»ï¼šç‰Œé¢æ•°å€¼å³ä¸ºä¼¤å®³" },
                { hp: 200, atk: 35, mode: "value", desc: "é‡å‡»ï¼šç‰Œé¢æ•°å€¼å³ä¸ºä¼¤å®³" },
                { hp: 250, atk: 40, mode: "value", desc: "é‡å‡»ï¼šç‰Œé¢æ•°å€¼å³ä¸ºä¼¤å®³" },
                { hp: 300, atk: 45, mode: "value", desc: "é‡å‡»ï¼šç‰Œé¢æ•°å€¼å³ä¸ºä¼¤å®³" }
            ]
        },
        "enemy_8": { 
            name: "ç»ˆå±€é­”ç‹å¥ˆèŠ™è’‚", 
			img: "https://files.catbox.moe/0cqdjy.png",
			bgm: "https://files.catbox.moe/p6396r.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/dbavc4.png')",
            phases: [
                { hp: 1, atk: 30 },
                { hp: 1, atk: 35 },
                { hp: 1, atk: 40 },
                { hp: 1, atk: 50 }
            ]
        },
        "enemy_9": { 
            name: "ç¥é€‰çš„åœ£å¥³ç’æ³•", 
            img: "https://files.catbox.moe/x0iioz.png", 
			bgm: "https://files.catbox.moe/ypyat2.ogg",
            bg: "linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url('https://files.catbox.moe/o73s83.png')",
            phases: [
                { hp: 8, atk: 20, mode: "compare_asc", desc: "å‡åºï¼šåç‰Œ > å‰ç‰Œ æ—¶ä¼¤å®³" },
                { hp: 8, atk: 20, mode: "compare_desc", desc: "é™åºï¼šåç‰Œ < å‰ç‰Œ æ—¶ä¼¤å®³" },
                { hp: 8, atk: 20, mode: "compare_eq", desc: "åŒå·ï¼šåç‰Œ = å‰ç‰Œ æ—¶ä¼¤å®³" },
                { hp: 10, atk: 30, mode: "compare_all", desc: "å…¨åºï¼šå•å›åˆå†…é›†é½ å‡/é™/åŒ æ—¶ä¼¤å®³" }
            ]
        },
        "é»˜è®¤": { 
            name: "è¨“ç·´æœ¨æ¨", 
            img: "https://files.catbox.moe/cb2da1.png",
            phases: [{ hp: 50, atk: 5, mode: "count", desc: "ç·´ç¿’ï¼šå‡ºä¸€å¼µç‰Œ 1 å‚·å®³" }]
        }
    };

	const CHAR_TO_ENEMY_MAP = {
		"çˆ±å¨œ": "enemy_1", 
		"ç³": "enemy_4",   
		"ç±³æ‹‰éœ²æ©": "enemy_6",
		"é»›èŠ¬å¦®": "enemy_2",
		"èŠ™è•¾å˜‰": "enemy_5",
		"ç©—": "enemy_3",
		"è‰è¿ªå¨…": "enemy_7",
		"ç’æ³•": "enemy_9",
		"å¥ˆèŠ™è’‚": "enemy_8" 
	};

	let currentTargetName = "";
    let isLocalMuted = (typeof window.INJECTED_MUTE_STATE !== 'undefined') ? window.INJECTED_MUTE_STATE : false;

	function updateBgmButtonUI() {
        const btn = document.getElementById('bgm-toggle-btn');
        if (!btn) return;
        
        if (isLocalMuted) {
            btn.innerText = "ğŸ”‡";
            btn.style.color = "#ff6b6b";
        } else {
            btn.innerText = "ğŸ”Š";
            btn.style.color = "#fff";
        }
    }

    // åˆ‡æ›éŸ³æ¨‚é–‹é—œ
    async function toggleLocalMusic() {
        const btn = document.getElementById('bgm-toggle-btn');
        isLocalMuted = !isLocalMuted; // åˆ‡æ›ç‹€æ…‹

        updateBgmButtonUI(); // æ›´æ–°åœ–æ¨™

        if (window.parent && window.parent.RPGBridge && window.parent.RPGBridge.updateMuteState) {
            window.parent.RPGBridge.updateMuteState(isLocalMuted);
        }

        if (isLocalMuted) {
            if (window.parent && window.parent.RPGBridge) {
                await window.parent.RPGBridge.execute('/xbaudio play=off'); 
            }
        } else {
            playBattleMusic(); 
        }
    }
    
    // === 2. é€šè¨Šèˆ‡åˆå§‹åŒ– ===
    async function getST(varName) {
        if (window.parent && window.parent.RPGBridge) {
            return await window.parent.RPGBridge.getVar(varName);
        }
        return null;
    }

    async function execST(cmd) {
        if (window.parent && window.parent.RPGBridge) {
            return await window.parent.RPGBridge.execute(cmd);
        }
    }

    async function setST(varName, val) {
        if (window.parent && window.parent.RPGBridge) {
            return await window.parent.RPGBridge.setVar(varName, val);
        }
    }

    window.onload = async function() {
        initEnemySelector();
        await loadBattleData();
		updateBgmButtonUI();
        document.getElementById('loading-screen').style.display = 'none';
        document.getElementById('selection-screen').style.display = 'flex';
        initSelectionUI();
    };

    function initEnemySelector() {
		const sel = document.getElementById('debug-enemy-select');
		if (!sel) return;

		if (!IS_DEBUG_MODE) {
			if (sel.parentElement) sel.parentElement.style.display = 'none';
			return;
		}
        let html = '';
        Object.keys(ENEMIES_DB).forEach(key => {
            const name = ENEMIES_DB[key].name;
            html += `<option value="${key}">${name} (${key})</option>`;
        });
        sel.innerHTML = html;
        sel.value = "enemy_1";
    }

    let currentEnemyData = null;
    let availableSkills = [];

    async function loadBattleData() {
        const sel = document.getElementById('debug-enemy-select');
        let targetName = "é»˜è®¤";
        
        if (window.parent && window.parent.RPGBridge) {
            targetName = await window.parent.RPGBridge.getVar('ä¸–ç•Œ.è¿·å®«æ”»ç•¥.å½“å‰æ”»ç•¥å¯¹è±¡');
        }
        
        console.log("å½“å‰æ”»ç•¥å¯¹è±¡:", targetName);
        currentTargetName = targetName; 

        let enemyId = "enemy_1"; 

        if (!IS_DEBUG_MODE) {
            if (targetName && CHAR_TO_ENEMY_MAP[targetName]) {
                enemyId = CHAR_TO_ENEMY_MAP[targetName];
            } else {
                console.warn("æ­£å¼æ¨¡å¼ä¸‹æœªè®€å–åˆ°æœ‰æ•ˆç›®æ¨™ï¼Œä½¿ç”¨é è¨­æ•µäºº");
                enemyId = "enemy_1"; 
            }
        } else {
            if (sel && sel.value) {
                enemyId = sel.value;
            } else if (targetName && CHAR_TO_ENEMY_MAP[targetName]) {
                enemyId = CHAR_TO_ENEMY_MAP[targetName];
            }
        }
        
        if (!ENEMIES_DB[enemyId]) enemyId = "enemy_1";
        currentEnemyData = JSON.parse(JSON.stringify(ENEMIES_DB[enemyId]));
        
        // [æ–°å¢] æ‡‰ç”¨ BOSS å°ˆå±¬èƒŒæ™¯
        if (currentEnemyData.bg) {
            document.body.style.backgroundImage = currentEnemyData.bg;
        } else {
             document.body.style.backgroundImage = "radial-gradient(circle at center, #1a1512, #050403)";
        }

        // éš¨æ©ŸåŒ–è™•ç†
        if (enemyId === "enemy_2") {
            for (let i = currentEnemyData.phases.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentEnemyData.phases[i], currentEnemyData.phases[j]] = [currentEnemyData.phases[j], currentEnemyData.phases[i]];
            }
        }

        if (enemyId === "enemy_9") {
            const firstThree = [currentEnemyData.phases[0], currentEnemyData.phases[1], currentEnemyData.phases[2]];
            for (let i = firstThree.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [firstThree[i], firstThree[j]] = [firstThree[j], firstThree[i]];
            }
            currentEnemyData.phases[0] = firstThree[0];
            currentEnemyData.phases[1] = firstThree[1];
            currentEnemyData.phases[2] = firstThree[2];
        }

        if (enemyId === "enemy_8") {
            const modeGenerators = [
                // 1. åŸºç¤è¨ˆæ•¸ (åƒè€ƒ Enemy 1)
                // åŸç‰ˆ HP 10ï¼ŒBOSS ç‰ˆæå‡è‡³ 20
                () => ({ 
                    mode: "count", 
                    hp: 15,
                    params: {}, 
                    desc: "è®¡æ•°ï¼šå‡ºä¸€å¼ ç‰Œé€ æˆ 1 ä¼¤å®³" 
                }),
                
                // 2. é¡è‰²é€£æ“Š (åƒè€ƒ Enemy 2)

                () => {
                    const colors = ['red', 'blue', 'green', 'yellow'];
                    const cMap = {'red':'çº¢', 'blue':'è“', 'green':'ç»¿', 'yellow':'é»„'};
                    const picked = colors[Math.floor(Math.random() * colors.length)];
                    return { 
                        mode: "color_chain", 
                        hp: 5,
                        params: { color: picked }, 
                        desc: `åŒè‰²ï¼šè¿ç»­å‡º${cMap[picked]}ç‰Œé€ æˆä¼¤å®³` 
                    };
                },

                // 3. é¡è‰²è®Šæ› (åƒè€ƒ Enemy 3)
                // å®¹æ˜“è§¸ç™¼ï¼ŒHP èˆ‡åŸºç¤æŒå¹³
                () => ({ 
                    mode: "color_switch", 
                    hp: 10,
                    params: {}, 
                    desc: "å˜å¹»ï¼šåˆ‡æ¢é¢œè‰²æ—¶é€ æˆä¼¤å®³" 
                }),

                // 4. æ•¸å€¼è½å·® (åƒè€ƒ Enemy 4)
                // å¹³å‡ä¸€å¼µç‰Œèƒ½æ‰“ 2.5~3 å‚·å®³ï¼ŒHP éœ€è¦æ˜¯åŸºç¤çš„ 3 å€å·¦å³
                () => ({ 
                    mode: "diff", 
                    hp: 50,
                    params: {}, 
                    desc: "è½å·®ï¼šé€ æˆå‰åç‰Œå·®å€¼çš„ä¼¤å®³" 
                }),

                // 5. é€£æ“Šç¯€å¥ (åƒè€ƒ Enemy 5)
                // æ”»æ“Šé »ç‡æ¥µä½ (æ¯ 3~5 å¼µç‰Œæ‰æ‰“ä¸€ä¸‹)ï¼ŒHP å¿…é ˆæ¥µä½
                () => {
                    const mod = Math.floor(Math.random() * 3) + 3; // éš¨æ©Ÿ 3, 4, 5 é€£æ“Š

                    const adjustedHp = Math.floor(60 / mod / 4); 
                    return { 
                        mode: "combo_mod", 
                        hp: adjustedHp, 
                        params: { mod: mod }, 
                        desc: `èŠ‚å¥ï¼šæ¯ ${mod} è¿å‡»é€ æˆä¼¤å®³` 
                    };
                },

                // 6. ç¸½å’Œç›®æ¨™ (åƒè€ƒ Enemy 6)
                // è§¸ç™¼æ¥µé›£ï¼ŒHP å¿…é ˆå€‹ä½æ•¸
                () => {
                    const targets = [15, 20, 25]; // 10 å¤ªå®¹æ˜“äº†å…ˆæ‹¿æ‰
                    const t = targets[Math.floor(Math.random() * targets.length)];
                    return { 
                        mode: "sum_target", 
                        hp: 3, 
                        params: { target: t }, 
                        desc: `æ€»å’Œï¼šæ€»å’Œåˆšå¥½ ${t} é€ æˆä¼¤å®³` 
                    };
                },

                // 7. æ•¸å€¼é‡æ“Š (åƒè€ƒ Enemy 7)
       
                () => ({ 
                    mode: "value", 
                    hp: 100, 
                    params: {}, 
                    desc: "é‡å‡»ï¼šç‰Œé¢æ•°å€¼å³ä¸ºä¼¤å®³" 
                }),

                // 8. æ¯”è¼ƒå¤§å° (åƒè€ƒ Enemy 9)
                () => {
                    const types = [
                        { m: "compare_asc", d: "å‡åºï¼šåç‰Œ > å‰ç‰Œ", hp: 10 },
                        { m: "compare_desc", d: "é™åºï¼šåç‰Œ < å‰ç‰Œ", hp: 10 },
                        { m: "compare_eq", d: "åŒå·ï¼šåç‰Œ = å‰ç‰Œ", hp: 5 }, // åŒè™Ÿè¼ƒé›£
                        { m: "compare_all", d: "å…¨åºï¼šé›†é½ å‡/é™/åŒ", hp: 2 } // æœ€é›£
                    ];
                    const t = types[Math.floor(Math.random() * types.length)];
                    return { 
                        mode: t.m, 
                        hp: t.hp,
                        params: {}, 
                        desc: `${t.d} æ—¶ä¼¤å®³` 
                    };
                }
            ];

            // 1. æ´—ç‰Œ
            for (let i = modeGenerators.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [modeGenerators[i], modeGenerators[j]] = [modeGenerators[j], modeGenerators[i]];
            }

            currentEnemyData.phases.forEach((p, index) => {
                const generator = modeGenerators[index % modeGenerators.length];
                const config = generator();
                

                const stageMultiplier = 1 ; 
                
                p.mode = config.mode;
                p.params = config.params;
                p.hp = Math.floor(config.hp * stageMultiplier); // é€™è£¡è¨­å®šè¡€é‡
                p.maxHp = p.hp; // è¨˜å¾—æ›´æ–° maxHp
                p.desc = `[æ··æ²Œ${index+1}] ${config.desc}`;
            });
        }
        // === ä¿®æ”¹çµæŸ ===

        availableSkills = [];
        for (let skill of SKILLS_DB) {
            if (IS_DEBUG_MODE) {
                availableSkills.push(skill);
            } else {
                let status = await getST(`ä¸–ç•Œ.å¦ˆå¦ˆ.${skill.owner}.åœ¨é˜ŸçŠ¶æ€`);
                if (status === 'æ˜¯' || status === 'True' || status === 'true') {
                    availableSkills.push(skill);
                }
            }
        }
    }

    function closeGame() {
        if (window.parent && window.parent.RPGBridge) {
            window.parent.RPGBridge.closeGame();
        }
    }

    // === 3. éŠæˆ²æ ¸å¿ƒé‚è¼¯ ===
    const COLORS = ['red', 'blue', 'green', 'yellow'];
    const NUMBERS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const DEFENSE_PER_CARD = 3; 

    let deck = [], hand = [], discardPile = [], currentTurnCards = [];
    let enemy = { phaseIndex: 0, hp: 0, maxHp: 0, atk: 0, mode: "count", params: {} };
    let battleState = { sumAccumulator: 0, colorChainCount: 0, compareFlags: { asc: false, desc: false, eq: false } };
    let player = { hp: 100, maxHp: 100, equippedSkills: [], lives: 3 }; 
    let turnStats = { cardsPlayed: 0, damageDealt: 0, combo: 0 };
    let isFirstMoveOfTurn = false;
    let buffs = { extraDrawTurns: 0, keepHandTurns: 0 };
    
    let isPhaseBrokenThisTurn = false;

    let targetingMode = null; 
    let pendingColorSrc = null; 
    let selectedSkillIds = [];

    function initSelectionUI() {
        const grid = document.getElementById('skill-grid');
        grid.innerHTML = availableSkills.map(s => `
            <div class="sel-card" id="sel-skill-${s.id}" onclick="toggleSkillSelection(${s.id})">
                <div class="sel-owner">${s.owner}</div>
                <div class="sel-title">${s.name}</div>
                <div class="sel-desc">${s.desc}</div>
                <div style="margin-top:auto; font-size:0.8rem; color:#666; border-top:1px solid #444; padding-top:5px;">
                    æ¬¡æ•°: ${s.max} 
                </div>
            </div>
        `).join('');
        updateSelectionUI();
    }
    
    function toggleSkillSelection(id) {
        const idx = selectedSkillIds.indexOf(id);
        if (idx >= 0) {
            selectedSkillIds.splice(idx, 1);
        } else {
            if (selectedSkillIds.length < 4) selectedSkillIds.push(id);
        }
        updateSelectionUI();
    }
    
    function updateSelectionUI() {
        document.querySelectorAll('.sel-card').forEach(el => el.classList.remove('selected'));
        selectedSkillIds.forEach(id => {
            const el = document.getElementById(`sel-skill-${id}`);
            if(el) el.classList.add('selected');
        });
    }
    
    function finalizeSelection() {
        player.equippedSkills = selectedSkillIds.map(id => {
            const proto = availableSkills.find(s => s.id === id);
            return { ...proto, charges: proto.max };
        });
        document.getElementById('selection-screen').style.display = 'none';
        document.getElementById('game-stage').style.display = 'block';
        initGame();
    }

    function initGame() {
        document.getElementById('defeat-modal').style.display = 'none';
        document.getElementById('enemy-name').innerText = currentEnemyData.name;
        
        const phaseCount = Math.min(4, currentEnemyData.phases.length);
        const orbContainer = document.querySelector('.area-left');
        orbContainer.innerHTML = '<div class="lives-label">BOSS<br>PHASES</div>';
        for(let i=0; i<phaseCount; i++) {
            orbContainer.innerHTML += `<div class="life-orb" id="orb-${i+1}"></div>`;
        }

        loadEnemyPhase(0);

        const bossImg = document.getElementById('boss-img');
        if (currentEnemyData.img) {
            bossImg.src = currentEnemyData.img;
            bossImg.style.display = 'block';
        } else {
            bossImg.style.display = 'none';
        }

        deck = []; discardPile = []; hand = []; currentTurnCards = [];
        player.hp = 100;
        player.equippedSkills.forEach(s => s.charges = s.max);
        buffs = { extraDrawTurns: 0, keepHandTurns: 0, futureSightTurns: 0 };
        
        battleState = { sumAccumulator: 0, colorChainCount: 0, compareFlags: { asc: false, desc: false, eq: false } };
        
        COLORS.forEach(color => {
            NUMBERS.forEach(num => {
                deck.push({ color: color, number: num, isToken: false });
            });
        });
        shuffle(deck);
        startNewTurn();
		playBattleMusic();
    }

	async function playBattleMusic() {
        if (isLocalMuted) {
            updateBgmButtonUI();
            return; 
        }

        if (currentEnemyData && currentEnemyData.bgm) {
            console.log("[Minigame] æ’­æ”¾æˆ˜æ–—éŸ³ä¹:", currentEnemyData.bgm);
            if (window.parent && window.parent.RPGBridge) {
                await window.parent.RPGBridge.execute(`/xbaudio "${currentEnemyData.bgm}"`);
                updateBgmButtonUI();
            }
        }
    }

    function loadEnemyPhase(index) {
        const phases = currentEnemyData.phases;
        if (index >= phases.length) return false; 

        const pData = phases[index];
        enemy.phaseIndex = index;
        enemy.hp = pData.hp;
        enemy.maxHp = pData.hp;
        enemy.atk = pData.atk;
        enemy.mode = pData.mode;
        enemy.params = pData.params || {};
        
        document.getElementById('condition-text').innerText = pData.desc || "æ“Šæ•—æ•µäºº";
        
        battleState.sumAccumulator = 0;
        battleState.colorChainCount = 0;
        battleState.compareFlags = { asc: false, desc: false, eq: false };

        const bossImg = document.getElementById('boss-img');
        bossImg.classList.remove('phase-flash');
        void bossImg.offsetWidth;
        bossImg.classList.add('phase-flash');
        
        updateUI();
        return true;
    }
    
    async function retryGame() { 
        document.getElementById('defeat-modal').style.display = 'none';
        document.getElementById('game-stage').style.display = 'none';
		await loadBattleData();
        document.getElementById('selection-screen').style.display = 'flex';
        initSelectionUI(); 
    }

    async function skipBattle() {
        document.getElementById('defeat-modal').style.display = 'none';
        await handleVictory();
    }

    function startNewTurn() {
        turnStats.cardsPlayed = 0; turnStats.damageDealt = 0; turnStats.combo = 0;
        currentTurnCards = []; isFirstMoveOfTurn = true;
        
        cancelTargetingMode();
        
        battleState.colorChainCount = 0; 
        battleState.sumAccumulator = 0; 
        battleState.compareFlags = { asc: false, desc: false, eq: false };
        
        isPhaseBrokenThisTurn = false;
		
		if (buffs.futureSightTurns > 0) {
        buffs.futureSightTurns--;
        if (buffs.futureSightTurns === 0) {
            showLog("æœªæ¥è§†ç•Œæ•ˆæœç»“æŸ");
        }
    }
		
        if (buffs.keepHandTurns > 0) {
            showLog(`Buff: ä¿ç•™æ‰‹ç‰Œ (${buffs.keepHandTurns})`);
            buffs.keepHandTurns--;
        } else {
            if (hand.length > 0) {
                hand.forEach(c => { if(!c.isToken) discardPile.push(c); });
                hand = [];
            }
        }

        let drawCount = 5;
        if (buffs.extraDrawTurns > 0) {
            drawCount += 2;
            showLog(`Buff: å¤šæŠ½2å¼  (${buffs.extraDrawTurns})`);
            buffs.extraDrawTurns--;
        }

        for(let i=0; i<drawCount; i++) {
            const c = drawCardFromDeck();
            if(c) hand.push(c);
        }
        updateUI();
    }

    function drawCardFromDeck() {
        if (deck.length === 0) {
            const validDiscard = discardPile.filter(c => !c.isToken);
            if (validDiscard.length <= 0) return null; 
            
            deck = [...validDiscard];
            discardPile = [];
            shuffle(deck);
        }
        return deck.pop();
    }

    function playCard(index) {
        const card = hand[index];
        
        let effectiveTopCard = null;
        if (currentTurnCards.length > 0) {
            effectiveTopCard = currentTurnCards[currentTurnCards.length - 1];
        } else {
            effectiveTopCard = discardPile[discardPile.length - 1];
        }

        let isValid = false;

        if (isFirstMoveOfTurn) isValid = true;
        else if (effectiveTopCard) {
            if (card.color === effectiveTopCard.color || Math.abs(card.number - effectiveTopCard.number) === 1 || card.number === effectiveTopCard.number) isValid = true;
        }

        if (isValid) {
            hand.splice(index, 1);
            if (!card.isToken) discardPile.push(card);
            currentTurnCards.push(card);
            turnStats.cardsPlayed++;
            turnStats.combo++; 

            let bonusDraw = false;
            if (!isFirstMoveOfTurn && effectiveTopCard) {
                if (card.color === effectiveTopCard.color && Math.abs(card.number - effectiveTopCard.number) === 1) bonusDraw = true;
                if (card.color !== effectiveTopCard.color && card.number === effectiveTopCard.number) bonusDraw = true;
            }

            isFirstMoveOfTurn = false;
            if (bonusDraw) {
                const newCard = drawCardFromDeck();
                if (newCard) hand.push(newCard);
                showLog("BONUS DRAW!");
            }
            
            processDamageAction();
            updateUI();
        } else {
            const el = document.querySelectorAll('#hand-area .card')[index];
            if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); }
        }
    }

    function calculateInstantDamage() {
        const mode = enemy.mode || "count";
        const lastCard = currentTurnCards[currentTurnCards.length - 1];
        if (!lastCard) return 0; 

        let dmg = 0;

        if (mode === "count") {
            dmg = 1; 
        } 
        else if (mode === "color_chain") {
            const targetColor = enemy.params.color;
            if (lastCard.color !== targetColor) return 0;
            
            if (currentTurnCards.length >= 2) {
                const prev = currentTurnCards[currentTurnCards.length - 2];
                if (prev.color === targetColor) {
                    dmg = 1;
                }
            }
        }
        else if (mode === "color_switch") {
            if (currentTurnCards.length >= 2) {
                const prev = currentTurnCards[currentTurnCards.length - 2];
                if (lastCard.color !== prev.color) dmg = 1;
            }
        }
        else if (mode === "diff") {
            if (currentTurnCards.length >= 2) {
                const prev = currentTurnCards[currentTurnCards.length - 2];
                dmg = Math.abs(lastCard.number - prev.number);
            }
        }
        else if (mode === "combo_mod") {
            const mod = enemy.params.mod || 3;
            if (turnStats.combo > 0 && turnStats.combo % mod === 0) dmg = 1;
        }
        else if (mode === "sum_target") {
            const target = enemy.params.target || 15;
            battleState.sumAccumulator += lastCard.number;
            
            if (battleState.sumAccumulator === target) {
                dmg = 1;
                battleState.sumAccumulator = 0; 
            } else if (battleState.sumAccumulator > target) {
                battleState.sumAccumulator -= target; 
            }
        }
        else if (mode === "value") {
            dmg = lastCard.number;
        }
        else if (mode === "compare_asc") {
            if (currentTurnCards.length >= 2) {
                const prev = currentTurnCards[currentTurnCards.length - 2];
                if (lastCard.number > prev.number) dmg = 1;
            }
        }
        else if (mode === "compare_desc") {
            if (currentTurnCards.length >= 2) {
                const prev = currentTurnCards[currentTurnCards.length - 2];
                if (lastCard.number < prev.number) dmg = 1;
            }
        }
        else if (mode === "compare_eq") {
            if (currentTurnCards.length >= 2) {
                const prev = currentTurnCards[currentTurnCards.length - 2];
                if (lastCard.number === prev.number) dmg = 1;
            }
        }
        else if (mode === "compare_all") {
            if (currentTurnCards.length >= 2) {
                const prev = currentTurnCards[currentTurnCards.length - 2];
                if (lastCard.number > prev.number) battleState.compareFlags.asc = true;
                else if (lastCard.number < prev.number) battleState.compareFlags.desc = true;
                else battleState.compareFlags.eq = true;
                
                if (battleState.compareFlags.asc && battleState.compareFlags.desc && battleState.compareFlags.eq) {
                    dmg = 1;
                    battleState.compareFlags = { asc: false, desc: false, eq: false };
                }
            }
        }

        return dmg;
    }

    function processDamageAction() {
        const damage = calculateInstantDamage();
        if (damage > 0) {
            enemy.hp = Math.max(0, enemy.hp - damage);
            showLog(`- ${damage} `);
        }

        if (enemy.hp <= 0) {
            const hasNextPhase = loadEnemyPhase(enemy.phaseIndex + 1);
            if (hasNextPhase) {
                isPhaseBrokenThisTurn = true;
                showLog("BREAK!!");
            } else {
                handleVictory();
            }
        }
    }

    function cancelTargetingMode() {
        if (!targetingMode) return;
        targetingMode = null;
        pendingColorSrc = null;
        document.getElementById('color-picker').style.display = 'none';
        showLog("æ“ä½œå·²å–æ¶ˆ");
        updateUI();
    }

    function useSkill(index) {
        if (targetingMode) {
            if (targetingMode.type === 'MIMIC_SELECT') {
                if (index === targetingMode.skillIndex) {
                    cancelTargetingMode();
                    return;
                }
                resolveMimicSelection(index);
                return;
            }
            
            cancelTargetingMode();
            return;
        }
        
        const skill = player.equippedSkills[index];
        if (skill.charges <= 0) { showLog("æ¬¡æ•°å·²ç”¨å°½ï¼"); return; }

        if (skill.id === 2) { 
             if (player.equippedSkills.length <= 1) { showLog("æ— å…¶å®ƒæ”¯æ´å¯é€‰æ‹©"); return; }
             showLog("è¯·ç‚¹å‡»å¦ä¸€ä¸ªæ”¯æ´...");
             targetingMode = { type: 'MIMIC_SELECT', skillIndex: index }; 
             updateUI();
             return;
        }
        executeSkillLogic(skill.id, index);
    }

    function resolveMimicSelection(targetIndex) {
        const sourceIndex = targetingMode.skillIndex;
        const targetSkill = player.equippedSkills[targetIndex];
        if (targetSkill.id === 2) { showLog("æ— æ³•é€‰æ‹©è‡ªèº«"); return; }
        showLog(`å‘åŠ¨äº† ${targetSkill.name}`);
        targetingMode = null; 
        executeSkillLogic(targetSkill.id, sourceIndex);
    }

    function executeSkillLogic(skillId, costIndex) {
        const costSkill = player.equippedSkills[costIndex];
        switch (skillId) {
            case 1:
                costSkill.charges--;
                const count = hand.length === 0 ? 4 : 2;
                for(let i=0; i<count; i++) { const c=drawCardFromDeck(); if(c) hand.push(c); }
                showLog(`æŠ½ç‰Œ +${count}`); 
                updateUI(); 
                break;
            case 3:
                showLog("é€‰æ‹©ä¸¢å¼ƒæ‰‹ç‰Œ...");
                targetingMode = { type: 'DISCARD_HEAL', skillIndex: costIndex };
                updateUI(); break;
            case 4:
                showLog("é€‰æ‹©åˆ‡å‰²æ‰‹ç‰Œ...");
                targetingMode = { type: 'SPLIT', skillIndex: costIndex };
                updateUI(); break;
            case 5: // èŠ™è•¾å˜‰çš„æ–°æŠ€èƒ½é‚è¼¯
        costSkill.charges--;
        buffs.futureSightTurns = 3; // è¨­å®š Buff æŒçºŒ 3 å›åˆ (æœ¬å›åˆé–‹å§‹ç®—)
        showLog("å¼€å¯æœªæ¥è§†ç•Œ (3å›åˆ)"); 
        updateUI(); 
        break;
            case 6:
                showLog("é€‰æ‹©æ¥æºé¢œè‰²...");
                targetingMode = { type: 'COLOR_SRC', skillIndex: costIndex };
                updateUI(); break;
            case 7:
                costSkill.charges--;
                buffs.extraDrawTurns += 3;
                showLog("Buff: å›åˆæŠ½ç‰Œå¢åŠ "); updateUI(); break;
            case 8:
                costSkill.charges--;
                buffs.keepHandTurns += 3;
                showLog("Buff: æ‰‹ç‰Œä¿ç•™"); updateUI(); break;
        }
    }

    function handleCardClick(index) {
        if (targetingMode) {
            if (targetingMode.type === 'MIMIC_SELECT') {
                cancelTargetingMode();
                return;
            }

            const card = hand[index];
            const skillIdx = targetingMode.skillIndex; 

            if (targetingMode.type === 'DISCARD_HEAL') {
                hand.splice(index, 1);
                if (!card.isToken) discardPile.push(card);
                player.hp = Math.min(player.maxHp, player.hp + 20);
                player.equippedSkills[skillIdx].charges--;
                showLog("ç”Ÿå‘½ +20");
                targetingMode = null;
            }
            else if (targetingMode.type === 'SPLIT') {
                if (card.number <= 1) { showLog("æ•¸å­—å¤ªå°ç„¡æ³•åˆ‡å‰²"); return; }
                hand.splice(index, 1);
                if (!card.isToken) discardPile.push(card);
                const v1 = Math.floor(card.number/2);
                const v2 = card.number - v1;
                hand.push({color:card.color, number:v1, isToken:true, id:Math.random()}, {color:card.color, number:v2, isToken:true, id:Math.random()});
                player.equippedSkills[skillIdx].charges--;
                showLog(`åˆ‡å‰²ç‚º ${v1} & ${v2}`);
                targetingMode = null;
            }
            else if (targetingMode.type === 'COLOR_SRC') {
                pendingColorSrc = card.color;
                document.getElementById('color-picker').style.display = 'flex';
                return;
            }
            updateUI();
        } else {
            playCard(index);
        }
    }

    function resolveColorPick(targetColor) {
        const skillIdx = targetingMode.skillIndex;
        const srcColor = pendingColorSrc;
        let count = 0;
        for (let i = 0; i < hand.length; i++) {
            if (hand[i].color === srcColor) {
                const old = hand[i];
                hand[i] = { color: targetColor, number: old.number, isToken: true, id: Math.random() };
                if (!old.isToken) discardPile.push(old);
                count++;
            }
        }
        player.equippedSkills[skillIdx].charges--;
        showLog(`è½‰åŒ–äº† ${count} å¼µç‰Œ`);
        document.getElementById('color-picker').style.display = 'none';
        targetingMode = null; pendingColorSrc = null;
        updateUI();
    }

    function cancelColorPick() {
        cancelTargetingMode();
    }

    async function endTurn() {
        if (targetingMode) { 
            cancelTargetingMode();
            return; 
        }
        
        const currentEnemyAtk = isPhaseBrokenThisTurn ? 0 : enemy.atk;
        
        const defense = turnStats.cardsPlayed * DEFENSE_PER_CARD;
        const incoming = Math.max(0, currentEnemyAtk - defense);
        
        if (incoming > 0) {
            player.hp = Math.max(0, player.hp - incoming);
            showLog(`å—åˆ° ${incoming} ç‚¹ä¼¤å®³ï¼`);
        } else {
            if (isPhaseBrokenThisTurn) showLog("stunnedï¼");
            else showLog("guard !");
        }

        if (player.hp <= 0) {
            document.getElementById('defeat-modal').style.display = 'flex';
        } else {
            startNewTurn();
        }
    }

    async function handleVictory() {
        showLog("å‹åˆ©ï¼");
        
        const bridge = window.parent.RPGBridge;
        if (!bridge) {
            alert("é”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ°ä¸»ç¨‹å¼ Bridge");
            return;
        }

        try {
            if (currentTargetName && currentTargetName !== 'éæ”»ç•¥ä¸­') {
                await bridge.execute(`/xbsetvar ä¸–ç•Œ.å¦ˆå¦ˆ.${currentTargetName}.çŠ¶æ€ 3`);
                await bridge.execute(`/xbgetvar ä¸–ç•Œ.è¿·å®«æ”»ç•¥.å½“å‰æ”»ç•¥å¯¹è±¡ | /xbdelvar ä¸–ç•Œ.è¿·å®«æ”»ç•¥.å¯ç”¨åå•.{{pipe}}`);
				await bridge.execute(`/xbsetvar ä¸–ç•Œ.è¿·å®«æ”»ç•¥.å½“å‰æ”»ç•¥å¯¹è±¡ éæ”»ç•¥ä¸­`);
                sendMsgViaDOM(`æˆ°é¬¥çµæŸï¼æˆåŠŸæ”»ç•¥ ${currentTargetName}ï¼`);
            }
            
            setTimeout(() => {
                bridge.closeGame();
            }, 1000);

        } catch (e) {
            console.error("ç»“ç®—å¤±è´¥:", e);
            showLog("ç»“ç®—å‘ç”Ÿé”™è¯¯");
        }
    }

	function sendMsgViaDOM(message) {
    try {
        // 1. è·å–çˆ¶çº§çª—å£çš„ document
        let targetDoc = document;
        if (window.parent && window.parent !== window) {
            targetDoc = window.parent.document;
        }

        // 2. æ‰¾åˆ° SillyTavern çš„è¾“å…¥æ¡†å’Œå‘é€æŒ‰é’®
        const textarea = targetDoc.getElementById('send_textarea');
        const sendButton = targetDoc.getElementById('send_but');

        if (!textarea || !sendButton) {
            console.error("æ‰¾ä¸åˆ° SillyTavern çš„è¾“å…¥ç»„ä»¶");
            return false;
        }

        // 3. å¡«å…¥æ¶ˆæ¯å¹¶è§¦å‘ Input äº‹ä»¶ (è®© ST çŸ¥é“æœ‰å†…å®¹è¾“å…¥äº†)
        textarea.value = message;
        const inputEvent = new Event('input', { bubbles: true });
        textarea.dispatchEvent(inputEvent);

        // 4. æ¨¡æ‹Ÿç‚¹å‡»å‘é€æŒ‰é’® (è¿™ä¸€æ­¥ä¼šè§¦å‘ LLM å›å¤)
        sendButton.click();
        return true;

    } catch (e) {
        console.error("DOM å‘é€å¤±è´¥:", e);
        return false;
    }
}

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function updateUI() {
        const handDiv = document.getElementById('hand-area');
        
        let effectiveTopCard = null;
        if (!isFirstMoveOfTurn) {
            if (currentTurnCards.length > 0) {
                effectiveTopCard = currentTurnCards[currentTurnCards.length - 1];
            } else {
                effectiveTopCard = discardPile[discardPile.length - 1];
            }
        }

        handDiv.innerHTML = hand.map((c, i) => {
            let cls = `card ${c.color}`;
            if (c.isToken) cls += " token";
            if (targetingMode) {
                if (['DISCARD_HEAL', 'SPLIT', 'COLOR_SRC'].includes(targetingMode.type)) cls += " targetable";
            } else {
                if (effectiveTopCard) {
                    const match = (c.color === effectiveTopCard.color || Math.abs(c.number - effectiveTopCard.number) === 1 || c.number === effectiveTopCard.number);
                    if (!match) cls += " disabled";
                }
            }
            return `<div class="${cls}" onclick="handleCardClick(${i})">${c.number}</div>`;
        }).join('');

        const skillDiv = document.getElementById('equipped-skills-area');
        if (skillDiv) {
    skillDiv.innerHTML = `
        <div class="skill-title">æ¯çˆ±æ”¯æ´</div>
        <div class="skill-container">
            ${player.equippedSkills.map((s, i) => {
                let cls = 'skill-btn';
                if (targetingMode && targetingMode.skillIndex === i) cls += ' active';
                if (targetingMode && targetingMode.type === 'MIMIC_SELECT' && s.id !== 2) cls += ' targetable-skill';
                
                // ç²å–åœ–ç‰‡ï¼Œå¦‚æœæ²’æœ‰å®šç¾©å‰‡ä½¿ç”¨é€æ˜åœ–æˆ–é è¨­åœ–
                const imgUrl = SKILL_ICONS[s.owner] || ""; 
                
                return `
                <button class="${cls}" onclick="useSkill(${i})" ${s.charges <= 0 ? 'disabled' : ''}>
                    <img src="${imgUrl}" class="s-img" alt="${s.owner}">
                    
                    <span class="s-name">${s.name}</span>
                    
                    <span class="s-count">å‰©ä½™: ${s.charges}</span>
                </button>
            `}).join('')}
        </div>
    `;
	const fsArea = document.getElementById('future-sight-area');
    const fsList = document.getElementById('fs-cards-list');
    
    // åªæœ‰ç•¶ Buff å¤§æ–¼ 0 ä¸” ç‰Œåº«é‚„æœ‰ç‰Œæ™‚é¡¯ç¤º
    if (buffs.futureSightTurns > 0 && deck.length > 0) {
        fsArea.style.display = 'flex';
        
        // æŠ“å–ç‰Œåº«é ‚ç«¯çš„ 3 å¼µç‰Œ
        // å› ç‚ºæ˜¯ç”¨ pop() æŠ½ç‰Œï¼Œæ‰€ä»¥é™£åˆ—å°¾ç«¯ (length-1) æ˜¯ä¸‹ä¸€å¼µè¦æŠ½çš„ç‰Œ
        let previewHtml = '';
        const peekCount = Math.min(3, deck.length);
        
        for (let i = 1; i <= peekCount; i++) {
            // deck[deck.length - 1] æ˜¯ä¸‹ä¸€å¼µ
            const card = deck[deck.length - i];
            previewHtml += `<div class="mini-card fs-card-slot ${card.color}">${card.number}</div>`;
        }
        
        fsList.innerHTML = previewHtml;
    } else {
        fsArea.style.display = 'none';
    }
}

        document.getElementById('hp-text').innerText = `${enemy.hp}/${enemy.maxHp}`;
        document.getElementById('hp-bar').style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;
        document.getElementById('player-hp-text').innerText = player.hp;
        
        const defense = turnStats.cardsPlayed * DEFENSE_PER_CARD;
        const currentEnemyAtk = isPhaseBrokenThisTurn ? 0 : enemy.atk;
        const incoming = Math.max(0, currentEnemyAtk - defense);
        
        const intentBox = document.getElementById('intent-box');
        const intentLabel = document.getElementById('intent-label');
        const intentVal = document.getElementById('enemy-intent-val');

        if (isPhaseBrokenThisTurn) {
            intentBox.classList.add('broken');
            intentLabel.innerText = "BOSS STUNNED";
            intentVal.innerText = "BREAK";
        } else {
            intentBox.classList.remove('broken');
            intentLabel.innerText = "ä¼¤å®³é¢„å…†";
            intentVal.innerText = incoming;
        }

        document.getElementById('def-rate-text').innerText = DEFENSE_PER_CARD;
        document.getElementById('combo-count').innerText = turnStats.combo;
        document.getElementById('deck-count').innerText = deck.length;
        
        const sumDisplay = document.getElementById('sum-display');
        const specialStatus = document.getElementById('special-status');
        
        if (enemy.mode === 'sum_target') {
            sumDisplay.style.display = 'block';
            specialStatus.style.display = 'none';
            sumDisplay.innerText = `å½“å‰æ€»å’Œ: ${battleState.sumAccumulator} / ç›®æ ‡: ${enemy.params.target}`;
        } 
        else if (enemy.mode === 'compare_all') {
            sumDisplay.style.display = 'none';
            specialStatus.style.display = 'flex';
            specialStatus.innerHTML = `
                <span class="check-item ${battleState.compareFlags.asc ? 'done' : ''}">[å‡]</span>
                <span class="check-item ${battleState.compareFlags.desc ? 'done' : ''}">[é™]</span>
                <span class="check-item ${battleState.compareFlags.eq ? 'done' : ''}">[åŒ]</span>
            `;
        }
        else {
            sumDisplay.style.display = 'none';
            specialStatus.style.display = 'none';
        }
        
        const phaseTotal = Math.min(4, currentEnemyData.phases.length);
        const phasesLeft = currentEnemyData.phases.length - enemy.phaseIndex; 
        for(let i=1; i<=phaseTotal; i++) {
            const orb = document.getElementById(`orb-${i}`);
            if (i <= phasesLeft) orb.classList.remove('lost'); 
            else orb.classList.add('lost');
        }

        const trackDiv = document.getElementById('played-cards-track');
        if (currentTurnCards.length === 0) trackDiv.innerHTML = `<span>ç­‰å¾…å‡ºç‰Œ...</span>`;
        else {
            trackDiv.innerHTML = currentTurnCards.map(c => `<div class="mini-card ${c.color}">${c.number}</div>`).join('');
            trackDiv.scrollLeft = trackDiv.scrollWidth;
        }
    }

    function showLog(msg) {
        const el = document.getElementById('log-overlay');
        el.innerText = msg; el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 1500);
    }

    window.addEventListener('click', function(e) {
        if (!targetingMode) return;

        if (e.target.closest('.card') || 
            e.target.closest('.skill-btn') || 
            e.target.closest('.btn-full') || 
            e.target.closest('.ingame-skip-btn') ||
            e.target.closest('#color-picker')) {
            return;
        }

        cancelTargetingMode();
    });
</script>
</body>
</html>